# Graphql Rules

**Purpose**
This task is useful for tasks that involve graphql queries on the front end or building graphql apis on the backend


**GraphQL Code Generation**
Consistent type generation and query patterns

## 1: GraphQL Patterns

### 1.1 File Naming and Directory Structure

#### 1.1.1: Query, Mutation, and Subscription files and naming 
All graphql queries should be in their own files named with the type `*.graphql`. We should also namespace the file based on the backend the query belongs to
  - For example for queries made to the main application api, the file names should be `*.api.graphl` for queries maek
  - Fore queries made to the third party backend `codex` we can name qeuries as `*.codex.graphql`

#### 1.1.2: Server Side resolver, typedefs location and naming

For server side, resolver logic should be grouped by models or major namespaces/concepts in the codebase. These namespaces should be called extensions and should be single files with structured as `name.extension.ts`. Each extension file should contain resolver logic for queries and mutations related to the namespace as well as the graphql type defs. Colocation of typedefs and resolver logic helps for code organization
  
_Example: Orders Extension_

```ts
// graphql/extensions/orders.extension.ts
import gql from "graphql-tag";
import { Prisma } from "@prisma/client";
import { prisma } from "@/db";
import { MutationResolvers, QueryResolvers } from "@/generated/resolvers";

export const orderTypeDefs = gql` 

  type Order {
    id: ID!    
    fromToken: String!    
    toToken: String!    
    amountIn: BigInt!    
    amountOut: BigInt    
  }

  input CreateOrderInput {
    fromToken: String!
    amountIn: BigInt!
    toToken: String!    
  }

  extend type Query {
    orders: [Order!]!    
  }

  extend type Mutation {
    createOrder(input: CreateOrderInput!): Order!    
  }
`;

type OrderResolvers = {
  Query: Pick<
    QueryResolvers,
    | "getUserOrders"
    | "getOrder"
    | "getUserLimitOrders"
    | "getUserTWAPOrders"
    | "getUserSniperOrders"
  >;
  Mutation: Pick<
    MutationResolvers,
    "createOrder" | "updateOrder" | "createTWAPOrder" | "cancelOrder"
  >;
};

export const orderResolvers: OrderResolvers = {
  Query: {
    orders: async (_parent, _args, { user } ) => {
      if (!user) {
        throw new Unauthorized();
      }

      const orders = await prisma.order.findMany({
          where: { userId: user.id },
          orderBy: { createdAt: "desc" },
          take: resolvedLimit,
          skip: resolvedOffset,
          include: {
            tokenIn: true,
            tokenOut: true,
          },
        });


      return orders
    }
  },
  Mutation: {
    createOrder: async (_parent, {input}, {user}) => {

         const order = await prisma.order.create({
          data: {...input, userId: user.id},         
        });

        return order
    }
  }
}

```

- Note that when we use codegen like this, we shouldn't have to manually type our function resolvers. They should get their types from the generated resolver types as shown in the example.

## 1.2 Type Generation: Automatic TypeScript types from GraphQL schemas
- **Fragment Usage**: Shared fragments for consistent data fetching

#### 1.2.1 Front End Types & Codegen

**GOAL:** We for *every* graphql query, mutation, subscription we should use codegen generated types for the response and query inputs as opposed to manually created types.


```typescript
// codegen.ts configuration
const config: CodegenConfig = {
  overwrite: true,
  generates: {
    'app/types/api.generated.ts': {
      schema: process.env.EXCHANGE_API_HTTP_URL,
      documents: './**/*.indexer.graphql',
      plugins: ['typescript', 'typescript-operations', 'fragment-matcher'],
    },
  },
  config: {
    maybeValue: 'T | undefined',
    skipTypename: true,
    enumsAsTypes: true,
  },
}
```

Note the packages required for frontend codegen:

Dev Dependencies:
@graphql-codegen/cli
@graphql-codegen/typescript
@graphql-codegen/typescript-graphql-request
@graphql-codegen/typescript-operations
graphql
graphql-request


Using Codegen:
IMPORTANT: We use codegen both for types and graphql document object.

Workflow:
1. Define the graphql query ina graphql file
2. Run `yarn codegen`
3. Call the query the the types and gql document generated by codegen

Example
```ts
import { GetOrderDocument, GetOrderQuery, GetOrderQueryVariables } from '@/generated/api.generated'

const response = await getConfig().graphqlQuery<
    GetOrderQuery,
    GetOrderQueryVariables
  >(GetOrderDocument, {
    id: orderId,
})

```

#### 1.2.2 Backend End Types & Codegen

**ABSOLUTE RULE**: Codegen must be used to generate all types for resolvers. Under NO circumstances should resolver function parameters be explicitly typed. This is a hard requirement with zero exceptions.

**If you encounter TypeScript errors in resolvers:**
1. The GraphQL typedefs may be missing or incorrect
2. Codegen may not have been run after schema changes
3. The resolver may not be included in the type definition

**The solution is NEVER to add explicit typing - always fix the root cause.**

_Example codegen config for resolvers:_

```ts
import { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
  overwrite: true,
  generates: {   
    "src/generated/resolvers.ts": {
      plugins: [
        "@graphql-codegen/typescript",
        "@graphql-codegen/typescript-operations",
        "@graphql-codegen/typescript-resolvers",
      ],
      schema: ["src/resolvers/*.ts", "src/extensions/*.ts"],
      config: {
        contextType: "src/schema/index#GraphqlContext",
        rootValueType: "src/schema/index#RootValue",
        mappers: {
          Decimal: "src/schema/index#Decimal",
          Hex: "string",
        },
        useIndexSignature: true,
        printFieldsOnNewLines: true,
        enumsAsTypes: true,
        scalars: {
          DateTime: "string | Date",
          BigInt: {
            input: "bigint",
            output: "bigint | Decimal",
          },
          Float: {
            input: "number",
            output: "number | string | Decimal",
          },
          Int: {
            input: "number",
            output: "number | string | Decimal",
          },
          OrderStatus: "string",
          EthereumAddress: "string",
          TxHash: "string",
          Hex: "string",
        },
      },
    },
  },
};

export default config;
```

Note the packages required for backend resolver generation:

Deps:
@graphql-tools/schema
@graphql-tools/stitch
graphql
graphql-request
graphql-scalars
graphql-subscriptions
graphql-tag

Dev Deps:
@graphql-codegen/cli
@graphql-codegen/introspection
@graphql-codegen/typescript
@graphql-codegen/typescript-graphql-request
@graphql-codegen/typescript-operations
@graphql-codegen/typescript-resolvers



#### 1.2.3 Applying codegen

Add the following scripts to package.json if not already present:
```
"codegen": "graphql-codegen --config codegen.ts",
"codegen:watch": "graphql-codegen --config codegen.ts --watch"
```
Then run `yarn codegen` to generate types

Types for the Graphql context should be stored as follows:
- contextType in `src/graphql/schema/graphql.types.ts` as `type GraphqlContext`,
- rootValueType: `src/graphql/schema/graphql.types.ts` as `type RootValue`,


#### 1.2.4 Common Mistakes to Avoid

**❌ WRONG - Explicit Parameter Typing:**
```typescript
// DON'T DO THIS
updateBuyCondition: async (
  _parent: any,
  args: MutationUpdateBuyConditionArgs,
  context: GraphqlContext
) => {
```

**✅ CORRECT - Let Codegen Handle Types:**
```typescript
// DO THIS INSTEAD
updateBuyCondition: async (_parent, args, context) => {
```

**Troubleshooting TypeScript Errors:**
1. Run `yarn run codegen` first
2. Ensure GraphQL typedefs are properly defined in the schema
3. Check that the resolver is included in the resolver type definition
4. Verify imports from `@/generated/resolvers` are correct

**Red Flags That Indicate Rule Violation:**
- Importing `GraphqlContext` directly in resolver files
- Importing specific mutation/query arg types (e.g., `MutationUpdateBuyConditionArgs`)
- Explicit typing of `_parent`, `args`, or `context` parameters
- Using `any` types in resolver parameters


#### 1.2.5 GraphQL Resolver Development Checklist

Before writing any resolver, ensure:

- [ ] GraphQL typedefs are defined in the extension file
- [ ] `yarn run codegen` has been run after adding new typedefs
- [ ] Resolver type definition includes the new resolver (e.g., in `Pick<MutationResolvers, ...>`)
- [ ] No explicit parameter typing in resolver functions
- [ ] No direct imports of `GraphqlContext` or specific arg types
- [ ] TypeScript compilation passes without errors

**Workflow:**
1. Add GraphQL typedefs to extension file
2. Update resolver type definition
3. Run `yarn run codegen`
4. Write resolver function with untyped parameters
5. Verify TypeScript compilation


#### 1.2.6 Rule Enforcement

**Code Review Requirements:**
- Any PR with explicit resolver parameter typing should be rejected
- Reviewers should verify `yarn run codegen` was run for GraphQL changes
- Look for imports of `GraphqlContext`, `Mutation*Args`, or `Query*Args` types in resolver files as red flags










